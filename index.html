<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Human OS — Deck Viewer & Exporter</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

    <style>
        :root{
            --card-w: 750px;
            --card-h: 1050px;
            --radius: 41px;
            --pad: 42px;

            --text: #0e0f14;
            --sub: #222633;
            --muted: #636a7e;
            --rule: rgba(16,16,19,.14);
            --glass: rgba(255,255,255,.72);
            --chip: rgba(255,255,255,.88);

            --shadow-card: 0 24px 56px rgba(0,0,0,.2), 0 8px 20px rgba(0,0,0,.12);
            --shadow-frame: 0 14px 28px rgba(0,0,0,.12);

            --pos: #0aa851;
            --neg: #e0443a;
            --zero: #6b7280;

            --playful-font: "Comic Sans MS", "Comic Neue", "Chalkboard SE", "Marker Felt",
            "Segoe Print", "Bradley Hand", "Trebuchet MS",
            system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        * { box-sizing: border-box; }
        html, body {
            margin: 0;
            background: radial-gradient(1200px 800px at 15% -10%, #ffffff, #f7f8fb 60%, #eef0f6 90%);
            color: var(--text);
            font-family: var(--playful-font);
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
            font-kerning: normal;
        }

        header {
            position: sticky; top: 0; z-index: 30;
            background: #ffffffdd; backdrop-filter: saturate(170%) blur(8px);
            border-bottom: 1px solid #e6e8ef;
            padding: 12px 16px;
            display: grid; gap: 10px;
            grid-template-columns: 1fr auto auto auto auto;
            align-items: center;
        }
        .brand { font-family: var(--playful-font); font-weight: 800; letter-spacing: .2px; font-size: 19px; }
        .count { color: var(--muted); font-size: 14px; }
        .controls { display: flex; align-items: center; gap: 10px; }
        input[type="file"]{ display:none; }
        .btn, label.btn {
            background:#121316; color:#fff; border:0; border-radius:14px; padding:10px 14px;
            font-weight: 700; font-size: 14px; cursor:pointer; box-shadow: 0 8px 18px rgba(0,0,0,.18);
            transition: transform .06s ease, box-shadow .12s ease, opacity .2s ease;
            font-family: var(--playful-font);
        }
        .btn.secondary, label.btn.secondary { background:#42434a; }
        .btn.ghost { background:#fff; color:#121316; border:1px solid #e5e7eb; }
        .btn:active { transform: translateY(1px); }
        .btn[disabled] { opacity:.55; cursor:not-allowed; box-shadow:none; }
        .select { padding: 9px 12px; border:1px solid #e5e7eb; border-radius: 12px; background:#fff; font-weight:700; font-family: var(--playful-font); }

        main {
            padding: 24px;
            display: grid; gap: 28px;
            grid-template-columns: repeat(auto-fill, minmax(calc(var(--card-w) + 28px), 1fr));
            align-items: start;
        }

        .frame {
            width: calc(var(--card-w) + 28px);
            background: #fff;
            border-radius: 22px;
            padding: 14px;
            box-shadow: var(--shadow-frame);
        }

        .frame-top {
            display:flex; align-items:center; justify-content: space-between;
            margin-bottom: 10px;
        }
        .meta { display:flex; align-items:center; gap:8px; font-size:12px; color: var(--muted); }
        .select-box { transform: scale(1.15); }

        .card {
            position: relative;
            width: var(--card-w);
            height: var(--card-h);
            border-radius: var(--radius);
            overflow: hidden;
            display: grid;
            gap: 12px;
            grid-template-rows: auto auto 1fr auto auto;
            box-shadow: var(--shadow-card);
            transform: translateZ(0);
            isolation: isolate;
        }

        .bg { position:absolute; inset:0; background: var(--bg, #fff); }
        .bg::before {
            content:""; position:absolute; inset:-20%;
            background:
                    conic-gradient(from 200deg at 20% 10%, rgba(255,255,255,.66), transparent 35%),
                    conic-gradient(from 40deg at 85% 20%, rgba(255,255,255,.5), transparent 40%),
                    conic-gradient(from 120deg at 50% 100%, rgba(255,255,255,.4), transparent 45%);
            filter: blur(14px); pointer-events:none;
        }
        .bg::after {
            content:""; position:absolute; inset:0;
            background-image: radial-gradient(circle at 12px 12px, rgba(255,255,255,.42) 2px, transparent 2px);
            background-size: 28px 28px;
            opacity:.5; mix-blend-mode: screen; pointer-events:none;
        }
        .sheen { position:absolute; inset:0; background: linear-gradient(180deg, rgba(255,255,255,.32), rgba(255,255,255,0) 22%, rgba(0,0,0,0) 78%, rgba(0,0,0,.06)); pointer-events:none; }

        .content {
            position: relative; z-index: 1;
            padding: var(--pad);
            display:grid; gap: 16px;
            grid-template-rows: auto auto 1fr auto auto;
        }

        .topbar { display:flex; justify-content: space-between; align-items: center; gap: 12px; }

        .badge {
            font-family: var(--playful-font);
            padding: 9px 14px; border-radius: 999px;
            background: var(--chip);
            font-weight: 800; font-size: 13px; letter-spacing:.3px;
            box-shadow: inset 0 0 0 1px rgba(0,0,0,.06);
        }

        .quick {
            display:flex; gap: 8px; align-items: center; flex-wrap: wrap;
            background: rgba(255,255,255,.58);
            padding: 6px 8px; border-radius: 999px;
            box-shadow: inset 0 0 0 1px rgba(0,0,0,.06);
        }
        .qchip {
            display:flex; align-items:center; gap: 6px;
            font-weight: 800; font-size: 15px;
            padding: 7px 10px; border-radius: 999px;
            background: rgba(255,255,255,.9);
            box-shadow: inset 0 0 0 1px rgba(0,0,0,.06);
            font-family: var(--playful-font);
        }
        .q-val.pos{ color: var(--pos); }
        .q-val.neg{ color: var(--neg); }
        .q-val.zero{ color: var(--zero); }

        .title {
            font-family: var(--playful-font);
            text-align: center; font-weight: 800; font-size: 44px; line-height: 1.08;
            color: var(--text); margin-top: 0;
        }
        .title .t-inner { display:inline; }
        .title br { display:block; }

        .rule { height: 2px; background: var(--rule); margin: 6px 0 8px; border-radius: 2px; }

        .desc {
            font-size: 24.5px; line-height: 1.56; color: var(--sub);
            padding: 18px 18px;
            background: var(--glass);
            border-radius: 18px;
            box-shadow: inset 0 0 0 1px rgba(0,0,0,.06);
            min-height: 240px;
            font-family: var(--playful-font);
        }

        .effects {
            display:flex; flex-direction: column; gap: 11px;
            padding: 16px 18px;
            background: var(--glass);
            border-radius: 18px;
            box-shadow: inset 0 0 0 1px rgba(0,0,0,.06);
            min-height: 340px;
        }
        .effect-head {
            font-family: var(--playful-font);
            font-weight: 800; font-size: 26px; letter-spacing:.2px; margin-bottom: 2px;
        }

        .eff-row {
            display:grid;
            grid-template-columns: 40px 1fr;
            column-gap: 12px; row-gap: 6px;
            align-items: start;
            padding: 11px 13px;
            border-radius: 14px;
            background: rgba(255,255,255,.9);
            box-shadow: inset 0 0 0 1px rgba(0,0,0,.05);
            font-family: var(--playful-font);
        }
        .eff-ico { font-size: 24px; line-height: 1; padding-top: 1px; }

        .eff-line {
            display: flex;
            align-items: baseline;
            gap: 10px;
            flex-wrap: nowrap;
            white-space: nowrap;
            min-width: 0;
            font-size: 21px; line-height: 1.38; color: var(--text);
        }
        .eff-label, .eff-val { white-space: nowrap; flex: 0 0 auto; }
        .eff-val { font-weight: 800; }
        .eff-val.pos  { color: var(--pos); }
        .eff-val.neg  { color: var(--neg); }
        .eff-val.zero { color: var(--zero); }

        .eff-reason{
            position: relative;
            flex: 1 1 auto;
            min-width: 0;
            white-space: normal;
            word-break: break-word;
            color: var(--muted);
            --dash-width: 1em;
            --dash-gap: .35ch;
            padding-left: calc(var(--dash-width) + var(--dash-gap));
        }
        .eff-reason::before{
            content: "—";
            position: absolute;
            left: 0; top: 0;
            width: var(--dash-width);
            text-align: center;
        }

        .brandline {
            text-align:center; color: var(--muted); font-size: 13px; margin-top: 0;
            letter-spacing:.28px; font-weight: 700;
            font-family: var(--playful-font);
        }

        .hide-chrome header, .hide-chrome .frame-top { display:none !important; }
        .hide-chrome main { grid-template-columns: 1fr; padding: 0; }
        .hide-chrome .frame { box-shadow:none; background: transparent; padding:0; width: var(--card-w); }
        .hide-chrome .card { box-shadow:none; }

        .exporting * { transition:none !important; animation:none !important; }
        .exporting .card:hover { transform:none; }

        .export-stage {
            position: fixed;
            top: 0; left: 0;
            z-index: 2147483647;
            pointer-events: none;
            opacity: 0;
            background: transparent;
        }
    </style>
</head>
<body>
<header>
    <div class="brand">HUMAN OS — Deck Viewer</div>
    <div class="count" id="count">Loading…</div>

    <div class="controls">
        <label class="btn secondary" for="csvInput">Load CSV</label>
        <input id="csvInput" type="file" accept=".csv" />
        <select id="scaleSelect" class="select" title="Export Quality">
            <option value="2">Export Scale: 2x</option>
            <option value="3">Export Scale: 3x</option>
            <option value="4" selected>Export Scale: 4x</option>
        </select>
        <button id="exportSelected" class="btn">Export Selected</button>
        <button id="exportAll" class="btn ghost">Export ALL</button>
    </div>
</header>

<main id="grid"></main>

<script>
    const CSV_DEFAULT = "cards.csv";

    const grid = document.getElementById('grid');
    const countEl = document.getElementById('count');
    const inputEl = document.getElementById('csvInput');
    const exportAllBtn = document.getElementById('exportAll');
    const exportSelBtn = document.getElementById('exportSelected');
    const scaleSelect = document.getElementById('scaleSelect');

    const s = (x) => (x ?? "").toString().trim();

    const nextFrame = () => new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
    const pause = (ms)=> new Promise(r => setTimeout(r, ms));

    async function waitForFontsReady() {
        try {
            if (document.fonts && document.fonts.ready) {
                const probes = [
                    document.fonts.load('800 44px "Comic Sans MS"'),
                    document.fonts.load('800 44px "Trebuchet MS"'),
                    document.fonts.load('800 44px system-ui')
                ];
                await Promise.race([
                    Promise.allSettled(probes),
                    new Promise(resolve => setTimeout(resolve, 500))
                ]);
                await document.fonts.ready;
            }
        } catch(_) {}
        await nextFrame();
    }

    function debounce(fn, t=150){ let id; return (...a)=>{ clearTimeout(id); id=setTimeout(()=>fn(...a), t); }; }

    function normalizeVal(raw){
        const t = s(raw);
        if (t.startsWith('+')) return { text: t, cls: 'pos' };
        if (t.startsWith('-')) return { text: t, cls: 'neg' };
        const num = parseFloat(t);
        if (!isNaN(num)) {
            if (num > 0) return { text: `+${num}`, cls: 'pos' };
            if (num < 0) return { text: `${num}`,  cls: 'neg' };
            return { text: '0', cls: 'zero' };
        }
        return { text: t || '0', cls: (t === '0' ? 'zero' : 'zero') };
    }
    function qchip(emoji, v) {
        const n = normalizeVal(v);
        return `<div class="qchip"><span>${emoji}</span><span class="q-val ${n.cls}">${n.text}</span></div>`;
    }
    function resRow(emoji, label, value, reason){
        const n = normalizeVal(value);
        return `
        <div class="eff-row">
          <div class="eff-ico">${emoji}</div>
          <div class="eff-line">
            <span class="eff-label">${label}</span>
            <span class="eff-val ${n.cls}">${n.text}</span>
            <span class="eff-reason">${s(reason)}</span>
          </div>
        </div>
      `;
    }

    const measureCanvas = document.createElement('canvas');
    const measureCtx = measureCanvas.getContext('2d');

    function getFontCSS(el){
        const cs = getComputedStyle(el);
        return `${cs.fontWeight} ${cs.fontSize} ${cs.fontFamily}`;
    }

    function balanceTitleToTwoLines(el){
        const original = el.dataset.originalTitle ?? el.textContent.trim();
        el.dataset.originalTitle = original;

        const words = original.split(/\s+/);
        if (words.length < 3) { el.innerHTML = `<span class="t-inner">${original}</span>`; return; }

        measureCtx.font = getFontCSS(el);
        const containerWidth = el.clientWidth || el.getBoundingClientRect().width;
        const fullWidth = measureCtx.measureText(original).width;
        if (fullWidth <= containerWidth) {
            el.innerHTML = `<span class="t-inner">${original}</span>`;
            return;
        }

        const mid = Math.floor(words.length/2);
        let bestIdx = 1, bestDiff = Infinity;
        const start = Math.max(1, mid - 4);
        const end   = Math.min(words.length - 1, mid + 4);

        for (let i = start; i <= end; i++){
            const left  = words.slice(0, i).join(' ');
            const right = words.slice(i).join(' ');
            const diff = Math.abs(measureCtx.measureText(left).width - measureCtx.measureText(right).width);
            if (diff < bestDiff) { bestDiff = diff; bestIdx = i; }
        }

        const line1 = words.slice(0, bestIdx).join(' ');
        const line2 = words.slice(bestIdx).join(' ');
        el.innerHTML = `<span class="t-inner">${line1}</span><br><span class="t-inner">${line2}</span>`;
    }

    function balanceAllTitles(){ document.querySelectorAll('.title').forEach(balanceTitleToTwoLines); }
    const rebalanceOnResize = debounce(()=>{ balanceAllTitles(); }, 120);
    window.addEventListener('resize', rebalanceOnResize);

    function cardHTML(row, idx){
        const bg = s(row.Background) || "#ffffff";
        const title = s(row.Title);
        const desc  = s(row.Description);

        const money = s(row.Money);
        const happy = s(row.Happiness);
        const social = s(row.Social);
        const energy = s(row.Energy);

        const mR = s(row.MoneyReason || "Money changes.");
        const hR = s(row.HappinessReason || "Mood changes.");
        const sR = s(row.SocialReason || "Social life changes.");
        const eR = s(row.EnergyReason || "Energy changes.");

        return `
        <div class="frame" data-i="${idx+1}">
          <div class="frame-top">
            <div class="meta">
              <input type="checkbox" class="select-box" data-target="card-${idx+1}" />
              <span>#${idx+1}</span>
            </div>
            <div class="meta">
              <button class="btn secondary" onclick="exportOne(${idx+1})">Export PNG</button>
            </div>
          </div>

          <div class="card" id="card-${idx+1}">
            <div class="bg" style="--bg:${bg}"></div>
            <div class="sheen"></div>

            <div class="content">
              <div class="topbar">
                <div class="badge">SCENARIO CARD</div>
                <div class="quick">
                  ${qchip("💵", money)}
                  ${qchip("🙂", happy)}
                  ${qchip("🗣️", social)}
                  ${qchip("⚡", energy)}
                </div>
              </div>

              <div>
                <div class="title" data-original-title="${title}">${title}</div>
                <div class="rule"></div>
              </div>

              <div class="desc">${desc}</div>

              <div class="effects">
                <div class="effect-head">Effect</div>
                ${resRow("💵", "Money", money, mR)}
                ${resRow("🙂", "Happiness", happy, hR)}
                ${resRow("🗣️", "Social", social, sR)}
                ${resRow("⚡", "Energy", energy, eR)}
              </div>

              <div class="brandline">Human OS</div>
            </div>
          </div>
        </div>
      `;
    }

    (async function init(){
        try {
            const res = await fetch(CSV_DEFAULT, { cache: "no-cache" });
            if (!res.ok) throw new Error("No default CSV");
            const text = await res.text();
            const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
            render(parsed.data);
        } catch {
            countEl.textContent = "Load your cards.csv with the button.";
        }
    })();

    async function render(rows){
        const data = rows.filter(r => s(r.Title));
        grid.innerHTML = data.map((r,i) => cardHTML(r,i)).join('');
        countEl.textContent = `${data.length} cards`;

        await waitForFontsReady();
        balanceAllTitles();

        [...document.querySelectorAll('.card')].forEach(c => {
            c.addEventListener('mouseenter', () => c.scrollIntoView({ block: 'nearest', behavior: 'smooth' }));
        });
    }

    async function capture(el){
        const scale = parseInt(scaleSelect.value || "4", 10);
        const width = el.offsetWidth;
        const height = el.offsetHeight;

        await waitForFontsReady();

        const stage = document.createElement('div');
        stage.className = 'export-stage';
        stage.style.width = width + 'px';
        stage.style.height = height + 'px';

        const clone = el.cloneNode(true);
        clone.style.transform = 'none';
        clone.style.isolation = 'auto';
        clone.style.width = width + 'px';
        clone.style.height = height + 'px';

        stage.appendChild(clone);
        document.body.appendChild(stage);
        await nextFrame();
        stage.querySelectorAll('.title').forEach(balanceTitleToTwoLines);

        const canvas = await html2canvas(clone, {
            backgroundColor: null,
            scale,
            useCORS: true,
            foreignObjectRendering: true,
            letterRendering: true,
            width,
            height,
            windowWidth: Math.max(1024, width + 20),
            windowHeight: Math.max(1024, height + 20),
            scrollX: 0,
            scrollY: 0
        });

        document.body.removeChild(stage);
        return canvas;
    }

    async function exportElement(el, filename){
        const canvas = await capture(el);
        return new Promise(resolve => {
            canvas.toBlob(blob => {
                if (blob) saveAs(blob, filename);
                resolve();
            }, 'image/png');
        });
    }

    async function exportOne(n){
        const el = document.getElementById(`card-${n}`);
        if (!el) return;
        document.body.classList.add('hide-chrome','exporting');
        exportAllBtn.disabled = true;
        exportSelBtn.disabled = true;
        try {
            countEl.textContent = `Exporting #${n}…`;
            await nextFrame();
            await exportElement(el, `${n}.png`);
            countEl.textContent = `Done — exported #${n}`;
        } catch (e){
            console.error(e);
            countEl.textContent = `Error exporting #${n}`;
        } finally {
            document.body.classList.remove('hide-chrome','exporting');
            exportAllBtn.disabled = false;
            exportSelBtn.disabled = false;
        }
    }
    window.exportOne = exportOne;

    exportAllBtn.addEventListener('click', async () => {
        const cards = [...document.querySelectorAll('.card')];
        if (!cards.length) return;

        exportAllBtn.disabled = true;
        exportSelBtn.disabled = true;
        document.body.classList.add('hide-chrome','exporting');

        try {
            await waitForFontsReady();
            balanceAllTitles();

            for (let i=0; i<cards.length; i++){
                const el = cards[i];
                const idx = (i+1).toString();
                countEl.textContent = `Exporting ${idx}/${cards.length}…`;
                await nextFrame();
                await exportElement(el, `${idx}.png`);
                await pause(60);
            }

            countEl.textContent = `Done — exported ${cards.length} PNG${cards.length>1?'s':''}.`;
        } catch (e){
            console.error(e);
            countEl.textContent = `Error during export. See console.`;
        } finally {
            document.body.classList.remove('hide-chrome','exporting');
            exportAllBtn.disabled = false;
            exportSelBtn.disabled = false;
        }
    });

    exportSelBtn.addEventListener('click', async () => {
        const checks = [...document.querySelectorAll('.select-box:checked')];
        if (checks.length === 0) return;

        exportAllBtn.disabled = true;
        exportSelBtn.disabled = true;
        document.body.classList.add('hide-chrome','exporting');

        try {
            await waitForFontsReady();
            balanceAllTitles();

            for (let i=0; i<checks.length; i++){
                const cb = checks[i];
                const targetId = cb.getAttribute('data-target');
                const el = document.getElementById(targetId);
                if (!el) continue;
                const idx = targetId.split('-')[1];

                countEl.textContent = `Exporting ${i+1}/${checks.length} (card #${idx})…`;
                await nextFrame();
                await exportElement(el, `${idx}.png`);
                await pause(60);
            }

            countEl.textContent = `Done — exported ${checks.length} PNG${checks.length>1?'s':''}.`;
        } catch (e){
            console.error(e);
            countEl.textContent = `Error during export. See console.`;
        } finally {
            document.body.classList.remove('hide-chrome','exporting');
            exportAllBtn.disabled = false;
            exportSelBtn.disabled = false;
        }
    });

    inputEl.addEventListener('change', async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        const text = await file.text();
        const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
        render(parsed.data);
    });
</script>
</body>
</html>
